<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NSCache源码阅读</title>
    <link href="/2021/03/23/NSCache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2021/03/23/NSCache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>NSCache 是一种可变集合，用于临时存储在资源不足时容易被回收的 key-value 键值对。NSCache 具有字典的所有功能，并且还具备如下特性：</p><ul><li><strong>内存不足时，NSCache 会自动清理缓存，并且提供了是否需要清理的开关和缓存清理时的回调</strong>；</li><li><strong>NSCache 是线程安全的</strong>；</li><li><strong>区别于 NSMutableDictionary ，NSCache 不需要对 key 进行拷贝</strong>。</li></ul><p>在 SDWebImage 中就是使用 NSCache 来处理缓存的。接下来围绕以下两个问题去阅读 NSCache 的源码：</p><ol><li><strong>缓存的自动清理是如何实现的？</strong></li><li><strong>如何保证缓存操作的线程安全？</strong></li></ol><p>由于 ObjC 的 Foundation 框架开源，但是开源的<a href="https://github.com/gnustep/libs-base">GNUstep</a>是 Cocoa 框架互换框架，虽然不能与苹果的Cocoa实现完全相同，但是两者的行为和实现方式是一样的，或者说非常相似。另外Apple 开源了 Swift 的核心库，包含了 Swift 版本的 Foundation 框架源码<a href="https://github.com/apple/swift-corelibs-foundation">swift-corelibs-foundation</a>。接下来就从 GNUstep 和 Swift 版本的 Foundation 框架中去探寻 NSCache 的实现。</p><h1 id="GNUstep中的NSCache"><a href="#GNUstep中的NSCache" class="headerlink" title="GNUstep中的NSCache"></a>GNUstep中的NSCache</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">GS_GENERIC_CLASS</span>(<span class="hljs-title">NSCache</span>, <span class="hljs-title">KeyT</span>, <span class="hljs-title">ValT</span>) : <span class="hljs-title">NSObject</span></span><br>&#123;<br>  <span class="hljs-keyword">@private</span><br>  <span class="hljs-built_in">NSUInteger</span> _costLimit;    <span class="hljs-comment">// 最大缓存开销，默认为0，表示无限制</span><br>  <span class="hljs-built_in">NSUInteger</span> _totalCost;    <span class="hljs-comment">// 缓存对象的总开销</span><br>  <span class="hljs-built_in">NSUInteger</span> _countLimit;   <span class="hljs-comment">// 最大缓存数量，默认为0，表示无限制</span><br>  <span class="hljs-keyword">id</span> _delegate; <span class="hljs-comment">// 代理，当缓存对象被清理或者移除时会收到通知</span><br>  <span class="hljs-built_in">BOOL</span> _evictsObjectsWithDiscardedContent;  <span class="hljs-comment">// 是否回收废弃对象的标志</span><br>  <span class="hljs-built_in">NSString</span> *_name;  <span class="hljs-comment">// 缓存内容名称</span><br>  <span class="hljs-built_in">NSMapTable</span> *_objects; <span class="hljs-comment">// 缓存内容</span><br>  GS_GENERIC_CLASS(<span class="hljs-built_in">NSMutableArray</span>, ValT) *_accesses;    <span class="hljs-comment">// 缓存对象的LRU/LFU排序</span><br>  int64_t _totalAccesses;   <span class="hljs-comment">// 缓存对象的访问次数，用于LRU/LFU</span><br>&#125;<br><br>- (<span class="hljs-built_in">NSUInteger</span>) countLimit;<br>- (<span class="hljs-built_in">NSUInteger</span>) totalCostLimit;<br>- (<span class="hljs-keyword">id</span>) delegate;<br>- (<span class="hljs-built_in">BOOL</span>) evictsObjectsWithDiscardedContent;<br>- (<span class="hljs-built_in">NSString</span>*) name;<br>- (GS_GENERIC_TYPE(ValT)) objectForKey: (GS_GENERIC_TYPE(KeyT))key;<br>- (<span class="hljs-keyword">void</span>) removeAllObjects;<br>- (<span class="hljs-keyword">void</span>) removeObjectForKey: (GS_GENERIC_TYPE(KeyT))key;<br>- (<span class="hljs-keyword">void</span>) setCountLimit: (<span class="hljs-built_in">NSUInteger</span>)lim;<br>- (<span class="hljs-keyword">void</span>) setDelegate: (<span class="hljs-keyword">id</span>)del;<br>- (<span class="hljs-keyword">void</span>) setEvictsObjectsWithDiscardedContent: (<span class="hljs-built_in">BOOL</span>)b;<br>- (<span class="hljs-keyword">void</span>) setName: (<span class="hljs-built_in">NSString</span>*)cacheName;<br>- (<span class="hljs-keyword">void</span>) setObject: (GS_GENERIC_TYPE(ValT))obj forKey:(GS_GENERIC_TYPE(KeyT))key cost: (<span class="hljs-built_in">NSUInteger</span>)num;<br>- (<span class="hljs-keyword">void</span>) setObject: (GS_GENERIC_TYPE(ValT))obj forKey: (GS_GENERIC_TYPE(KeyT))key;<br>- (<span class="hljs-keyword">void</span>) setTotalCostLimit: (<span class="hljs-built_in">NSUInteger</span>)lim;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9a18f6008e34ef990510e35ad557c0b~tplv-k3u1fbpfcp-zoom-1.image" alt="NSCache的数据结构"></p><p>NSCacheDelegate 中提供了缓存即将清理的回调：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSCacheDelegate</span></span><br><br>- (<span class="hljs-keyword">void</span>) cache: (<span class="hljs-built_in">NSCache</span>*)cache willEvictObject: (<span class="hljs-keyword">id</span>)obj;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>GNUstep 中 NSCache 的实现将 cost、name、delegate、countlimit 都提供了 setter 和 getter 方法，而 Apple 的API中使用属性自动实现 setter、getter 的功能简化了这一操作。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b46a0518e38439fa04888c6d162e4d7~tplv-k3u1fbpfcp-zoom-1.image" alt="Apple中NSCache的API"></p><p>NSCache 使用类型为 NSMapTable 的 <code>_objects</code> 存储缓存的内容，使用 NSMutableArray 类型的 <code>_accesses</code> 存储需要在缓存淘汰算法中可能被淘汰的对象。提供了 cost 和 count 来标记缓存内容的大小，且标记了缓存访问的总次数<code>_totalAccesses</code>。<br>在 NSMapTable 和 NSMutableArray 中存储的是 _GSCachedObject 对象，该对象用来保存 cache 的基本信息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 缓存的对象，用于保存缓存对象的信息</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">_GSCachedObject</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>  <span class="hljs-keyword">@public</span><br>  <span class="hljs-keyword">id</span> object;    <span class="hljs-comment">// cache 内容</span><br>  <span class="hljs-built_in">NSString</span> *key;    <span class="hljs-comment">// cache 的 key</span><br>  <span class="hljs-keyword">int</span> accessCount;  <span class="hljs-comment">// cache 的访问次数</span><br>  <span class="hljs-built_in">NSUInteger</span> cost;  <span class="hljs-comment">// cache 对象的开销</span><br>  <span class="hljs-built_in">BOOL</span> isEvictable; <span class="hljs-comment">// cache 是否支持回收</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93633eecbb9640e58884d81d7241ccaf~tplv-k3u1fbpfcp-watermark.image" alt="GSCachedObject的数据结构"></p><h2 id="缓存淘汰的实现"><a href="#缓存淘汰的实现" class="headerlink" title="缓存淘汰的实现"></a>缓存淘汰的实现</h2><p>NSCache 提供了两个添加缓存对象的方法：<code>-setObject:forKey:cost:</code> 和 <code>-setObject:forKey:</code>，后一个方法的实现直接调用了前一个方法，传入 cost=0 。</p><p>NSCache 中缓存淘汰的时机是在添加对象时，即 <code>-setObject:forKey:cost:</code> 内，该方法的流程为：</p><ul><li>先根据 key 查看 <code>_objects</code> 中是否有旧的内容，有则先删除旧的</li><li>调用缓存淘汰算法</li><li>创建一个 _GSCachedObject 缓存对象，记录 object、key、cost，如果对象实现了 NSDiscardableContent 协议，则将缓存对象添加到 <code>_accesses</code>  数组中，在使用缓存淘汰算法时，就可以从  <code>_accesses</code>  去获取符合清理条件的缓存对象</li><li>将缓存对象添加到 <code>_objects</code> 中，并更新 cost</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>) setObject: (<span class="hljs-keyword">id</span>)obj forKey: (<span class="hljs-keyword">id</span>)key cost: (<span class="hljs-built_in">NSUInteger</span>)num &#123;<br>    <span class="hljs-comment">// 先根据key查看是否有旧的内容，有则先删除旧的</span><br>   _GSCachedObject *oldObject = [_objects objectForKey: key];<br>   _GSCachedObject *newObject;<br>   <br>   <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != oldObject) &#123;<br>      [<span class="hljs-keyword">self</span> removeObjectForKey: oldObject-&gt;key];<br>   &#125;<br>    <br>    <span class="hljs-comment">// 调用缓存淘汰算法</span><br>   [<span class="hljs-keyword">self</span> _evictObjectsToMakeSpaceForObjectWithCost: num];<br>    <br>    <span class="hljs-comment">// 创建一个_GSCachedObject对象，记录object、key、cost，</span><br>    newObject = [_GSCachedObject new];<br>    newObject-&gt;object = RETAIN(obj);<br>    newObject-&gt;key = RETAIN(key);<br>    newObject-&gt;cost = num;<br>    <br>    <span class="hljs-comment">// 如果对象实现了NSDiscardableContent协议，则将对象添加到 _accesses 数组中，在使用缓存淘汰算法时，就可以从 _accesses 去获取可以被清理的对象</span><br>   <span class="hljs-keyword">if</span> ([obj conformsToProtocol: <span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">NSDiscardableContent</span>)]) </span>&#123;<br>       newObject-&gt;isEvictable = <span class="hljs-literal">YES</span>;<br>       [_accesses addObject: newObject];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加到maptable中</span><br>   [_objects setObject: newObject forKey: key];<br>   RELEASE(newObject);<br>    <br>    <span class="hljs-comment">// 更新cost</span><br>   _totalCost += num;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于缓存淘汰的具体步骤为：</p><ul><li>依据 <code>_totalCost</code>、<code>_costLimit</code> 判断是否需要清理：只有当 cost 大于人工限制时才会清理，即手动设置了 <code> _costLimit</code>，默认的 <code> _costLimit = 0</code>。</li><li>用 <code>spaceNeeded</code> 标记需要释放的空间，使用<code>evictedKeys</code> 数组存储需要清理的对象的key</li><li>使用迭代器遍历 <code> _accesses</code> 数组 ，将满足清理条件的对象的 key 添加到 <code>evictedKeys</code> 数组中，清理的对象为：<strong>标记为可自动清理和低于平均访问次数的对象，平均访问次数 = （总访问次数/缓存数量 * 0.2） + 1，即清理使用频率较少的对象</strong>。</li><li>遍历 <code>evictedKeys</code> 数组，使用<code>removeObjectForKey:</code>方法进行清理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)_evictObjectsToMakeSpaceForObjectWithCost: (<span class="hljs-built_in">NSUInteger</span>)cost &#123;<br>    <span class="hljs-comment">// 判断是否需要清理</span><br>    <span class="hljs-comment">// 只有当 cost 大于人工限制时才会清理，即手动设置了 _costLimit</span><br>    <span class="hljs-comment">// 如果 _costLimit = 0 则不进行干预</span><br>    <span class="hljs-built_in">NSUInteger</span> spaceNeeded = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记需要释放的空间</span><br>    <span class="hljs-built_in">NSUInteger</span> count = [_objects count];<br><br>    <span class="hljs-keyword">if</span> (_costLimit &gt; <span class="hljs-number">0</span> &amp;&amp; _totalCost + cost &gt; _costLimit) &#123;<br>      spaceNeeded = _totalCost + cost - _costLimit;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理具体逻辑</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; (spaceNeeded &gt; <span class="hljs-number">0</span> || count &gt;= _countLimit)) &#123;<br>      <span class="hljs-built_in">NSMutableArray</span> *evictedKeys = <span class="hljs-literal">nil</span>;    <span class="hljs-comment">// 使用数组存储需要清理的对象，存储的为对象的key</span><br>      <span class="hljs-comment">// 平均访问次数 = （总访问次数/缓存数量 * 0.2） + 1</span><br>      <span class="hljs-built_in">NSUInteger</span> averageAccesses = ((_totalAccesses / (<span class="hljs-keyword">double</span>)count) * <span class="hljs-number">0.2</span>) + <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">NSEnumerator</span> *e = [_accesses objectEnumerator];<br>        _GSCachedObject *obj;<br><br>      <span class="hljs-keyword">if</span> (_evictsObjectsWithDiscardedContent) &#123;<br>  evictedKeys = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>      &#125;<br>  <br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">nil</span> != (obj = [e nextObject]))  &#123;<br>           <span class="hljs-comment">// 清理 设置了自动清理 并且 访问次数小于平均访问次数的对象</span><br>      <span class="hljs-keyword">if</span> (obj-&gt;accessCount &lt; averageAccesses &amp;&amp; obj-&gt;isEvictable) &#123;<br>                <span class="hljs-comment">// 标识这个对象是可销毁的，如果计数变量为0时将会释放这个对象</span><br>        [obj-&gt;object discardContentIfPossible];<br>        <span class="hljs-keyword">if</span> ([obj-&gt;object isContentDiscarded]) &#123;<br>                    <span class="hljs-built_in">NSUInteger</span> cost = obj-&gt;cost;<br>         obj-&gt;cost = <span class="hljs-number">0</span>;<br>                <br>                    <span class="hljs-comment">// 避免后续再次被清理</span><br>                    obj-&gt;isEvictable = <span class="hljs-literal">NO</span>;<br>                <br>                    <span class="hljs-comment">// 将需要被清理的对象的key 添加到清理数组中</span><br>                    <span class="hljs-keyword">if</span> (_evictsObjectsWithDiscardedContent) &#123;<br>[evictedKeys addObject: obj-&gt;key];<br>    &#125;<br>                <br>                    <span class="hljs-comment">// 更新总 cost</span><br>                    _totalCost -= cost;<br><br>            <span class="hljs-comment">// 释放了足够空间，则停止操作</span><br>    <span class="hljs-keyword">if</span> (cost &gt; spaceNeeded) &#123;<br><span class="hljs-keyword">break</span>;<br>                    &#125;<br>    <br>            <span class="hljs-comment">// 更新需要释放的空间</span><br>                    spaceNeeded -= cost;<br>&#125;<br>    &#125;<br>&#125;<br>      <br>      <span class="hljs-comment">// 这里进行清理操作</span><br>      <span class="hljs-keyword">if</span> (_evictsObjectsWithDiscardedContent) &#123;<br>            <span class="hljs-built_in">NSString</span> *key;<br>            e = [evictedKeys objectEnumerator];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">nil</span> != (key = [e nextObject])) &#123;<br>  [<span class="hljs-keyword">self</span> removeObjectForKey: key];<br>            &#125;<br>&#125;<br>       [evictedKeys release];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在遍历 <code>_accesses</code>  中的内容时，如果对象符合清理的条件，则使用了<code>discardContentIfPossible</code> 标识这个对象是可销毁的，如果计数变量为0时将会释放这个对象。同时对该对象做了一些额外的工作：将 cost 重置为 0，将 isEvictable 设置为 NO，避免后续再次被清理。然后再将对象添加到清理的数组后，更新总 cost。此时，判断如果释放了足够空间，则停止遍历操作，直接进行下一步–遍历清理数组，进行 remove 操作；否则更新需要释放的空间，进入下一次迭代。</p><p>最后再对所有需要清理的缓存对象调用了 <code>removeObjectForKey:</code> 方法进行清理，该方法的具体实现为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>) removeObjectForKey: (<span class="hljs-keyword">id</span>)key &#123;<br>  _GSCachedObject *obj = [_objects objectForKey: key];<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != obj) &#123;<br>        <span class="hljs-comment">// 告知代理方，即将清理缓存对象</span><br>        [_delegate cache: <span class="hljs-keyword">self</span> willEvictObject: obj-&gt;object];<br>        <br>        <span class="hljs-comment">// 更新总的访问次数</span><br>        _totalAccesses -= obj-&gt;accessCount;<br>        <br>        <span class="hljs-comment">// 移除对象</span><br>        [_objects removeObjectForKey: key];<br>        <br>        <span class="hljs-comment">// 移除LRU/LFU排序中的对象</span><br>        [_accesses removeObjectIdenticalTo: obj];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该方法中，先告知代理方，即将清理缓存对象，然后更新总的访问次数，最后移除对象，同时移除 LRU/LFU 排序数组中的对象。</p><p>在 NSCache 中，<strong>淘汰的对象为低于平均访问次数的对象</strong>，对象的访问频次在<code>-objectForKey:key</code> 中进行更新，同时将标记了自动清理的对象添加到 LRU/LFU 排序数组的末端:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objc"> - (<span class="hljs-keyword">id</span>) objectForKey: (<span class="hljs-keyword">id</span>)key &#123;<br>  _GSCachedObject *obj = [_objects objectForKey: key];<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == obj) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>   &#125;<br>  <br>   <span class="hljs-comment">// 如果标记了自动清理，则将对象添加到_accesses 的末端</span><br>   <span class="hljs-keyword">if</span> (obj-&gt;isEvictable) &#123;<br>      [_accesses removeObjectIdenticalTo: obj];<br>      [_accesses addObject: obj];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新访问自次数</span><br>    obj-&gt;accessCount++;<br>    _totalAccesses++;<br>    <span class="hljs-keyword">return</span> obj-&gt;object;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法中，将标记了可以被自动清理的缓存对象添加到 LRU/LFU 排序数组的末端这一步是非常重要的，这样可以使<strong>访问频次高的都聚集在数组的尾部，当进行清理的时候，从头部获取的都是访问频次较低的对象</strong>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f321bd88c0044e99369a661390018c7~tplv-k3u1fbpfcp-zoom-1.image" alt="排序数组中对象的访问频次"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>GNUstep 的 NSCache 使用 NSMapTable 存储缓存对象。NSMapTable 是 NSDictionary 的通用版本。</p><p>GNUstep 的 NSCache 自动清理逻辑为：NSCache 使用 LRU/LFU 进行缓存的清理，使用数组存储标记为可以被清理的对象，并且每次访问对象时，将该对象移动到数组的末端，即实现了一个 LRU/LFU 的排序数组。 NSCache 记录每个缓存对象的访问频次和总的访问频次，在筛选清理对象时，将<strong>（总访问次数/缓存数量 * 0.2） + 1作为平均访问次数</strong>，遍历 LRU/LFU 的排序数组，将低于平均访问次数的对象取出进行清理。如果已经释放了足够空间，则停止操作。</p><p> 但是在 GNUstep 中并未发现线程安全的逻辑。</p><h1 id="Swift中的NSCache"><a href="#Swift中的NSCache" class="headerlink" title="Swift中的NSCache"></a>Swift中的NSCache</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>在 Swift 版本中，采用一个 NSCacheEntry 类存储 cache 对象的相关信息，NSCacheEntry 的数据结构如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NSCacheEntry</span>&lt;<span class="hljs-title">KeyType</span> : <span class="hljs-title">AnyObject</span>, <span class="hljs-title">ObjectType</span> : <span class="hljs-title">AnyObject</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> key: <span class="hljs-type">KeyType</span><br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">ObjectType</span><br>    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> prevByCost: <span class="hljs-type">NSCacheEntry</span>?<br>    <span class="hljs-keyword">var</span> nextByCost: <span class="hljs-type">NSCacheEntry</span>?<br>    <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">key</span>: <span class="hljs-type">KeyType</span>, <span class="hljs-params">value</span>: <span class="hljs-type">ObjectType</span>, <span class="hljs-params">cost</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>        <span class="hljs-keyword">self</span>.key <span class="hljs-operator">=</span> key<br>        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value<br>        <span class="hljs-keyword">self</span>.cost <span class="hljs-operator">=</span> cost<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6bbc35e5359428d9bc0d342f036b8ec~tplv-k3u1fbpfcp-zoom-1.image" alt="NSCacheEntry的数据结构"></p><p>和 GNUstep 中的_GSCachedObject 缓存对象大致相同，都存储了key、value、cost，不同的是 NSCacheEntry 提供了 <code>prevByCost</code> 和 <code>nextByCost</code> ，用于实现双向链表。</p><p>在 Apple Swift 版的 NSCache 中，采用 Dictionary 存储缓存数据，实现了一个以缓存对象的 cost 升序的排序双向链表，提供 head 头节点，当需要淘汰缓存数据时，从头节点开始删除。同时，使用 NSLock 来保证线程安全。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fcae29ba1ec4da28fb7b5f699969570~tplv-k3u1fbpfcp-zoom-1.image" alt="cost升序的双向链表"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NSCache</span>&lt;<span class="hljs-title">KeyType</span> : <span class="hljs-title">AnyObject</span>, <span class="hljs-title">ObjectType</span> : <span class="hljs-title">AnyObject</span>&gt; : <span class="hljs-title">NSObject</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _entries <span class="hljs-operator">=</span> <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">NSCacheKey</span>, <span class="hljs-type">NSCacheEntry</span>&lt;<span class="hljs-type">KeyType</span>, <span class="hljs-type">ObjectType</span>&gt;&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _lock <span class="hljs-operator">=</span> <span class="hljs-type">NSLock</span>()  <span class="hljs-comment">// 用于线程安全的锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _totalCost <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _head: <span class="hljs-type">NSCacheEntry</span>&lt;<span class="hljs-type">KeyType</span>, <span class="hljs-type">ObjectType</span>&gt;?   <span class="hljs-comment">// 排序链表的头节点</span><br>    <br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> totalCostLimit: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 默认为0，无限制</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> countLimit: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 默认为0，无限制</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> evictsObjectsWithDiscardedContent: <span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> delegate: <span class="hljs-type">NSCacheDelegate</span>?<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">init</span>()</span> &#123;&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object</span>(<span class="hljs-params">forKey</span> <span class="hljs-params">key</span>: <span class="hljs-type">KeyType</span>)</span> -&gt; <span class="hljs-type">ObjectType</span>? &#123;<span class="hljs-operator">...</span>&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setObject</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">obj</span>: <span class="hljs-type">ObjectType</span>, <span class="hljs-params">forKey</span> <span class="hljs-params">key</span>: <span class="hljs-type">KeyType</span>)</span> &#123;<span class="hljs-operator">...</span>&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setObject</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">obj</span>: <span class="hljs-type">ObjectType</span>, <span class="hljs-params">forKey</span> <span class="hljs-params">key</span>: <span class="hljs-type">KeyType</span>, <span class="hljs-params">cost</span> <span class="hljs-params">g</span>: <span class="hljs-type">Int</span>)</span> &#123;<span class="hljs-operator">...</span>&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeObject</span>(<span class="hljs-params">forKey</span> <span class="hljs-params">key</span>: <span class="hljs-type">KeyType</span>)</span> &#123;<span class="hljs-operator">...</span>&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeAllObjects</span>()</span> &#123;<span class="hljs-operator">...</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c39c085f7f6446e3bf5fc82a6fe1b444~tplv-k3u1fbpfcp-zoom-1.image" alt="NSCache的数据结构"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>整个缓存的核心逻辑大部分在 <code>setObject(_: forKey: cost: )</code> 方法中，该方法做了以下几件事：</p><ol><li>将对象存储在 Dictionary 中</li><li>将对象加入排序链表中</li><li>执行淘汰策略</li><li>使用 NSlock 对整个插入和淘汰过程进行加锁</li></ol><p>先看一下执行淘汰之前的具体操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> g <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(g, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">let</span> keyRef <span class="hljs-operator">=</span> <span class="hljs-type">NSCacheKey</span>(key)<br><br>_lock.lock()    <span class="hljs-comment">// 对整个insert和淘汰过程进行lock</span><br><br><span class="hljs-keyword">let</span> costDiff: <span class="hljs-type">Int</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> _entries[keyRef] &#123;   <span class="hljs-comment">// 如果已存在相同key的对象，则更新字典中旧对象的value，如果新旧对象的cost不同，则删除sort中的旧元素并插入新元素</span><br>    costDiff <span class="hljs-operator">=</span> g <span class="hljs-operator">-</span> entry.cost   <span class="hljs-comment">// 计算旧对象和新对象cost的差值</span><br>    entry.cost <span class="hljs-operator">=</span> g  <span class="hljs-comment">// 更新旧对象的cost</span><br>    <br>    entry.value <span class="hljs-operator">=</span> obj   <span class="hljs-comment">// 更新旧对象的value</span><br>    <br>    <span class="hljs-keyword">if</span> costDiff <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;  <span class="hljs-comment">// 如果cost的差值 != 0，删除旧的，插入新的</span><br>        remove(entry)<br>        insert(entry)<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 不存在，则直接添加到字典中</span><br>    <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> <span class="hljs-type">NSCacheEntry</span>(key: key, value: obj, cost: g)<br>    _entries[keyRef] <span class="hljs-operator">=</span> entry<br>    insert(entry)<br>    <br>    costDiff <span class="hljs-operator">=</span> g<br>&#125;<br><br><span class="hljs-comment">// 更新总的cost</span><br>_totalCost <span class="hljs-operator">+=</span> costDiff<br></code></pre></td></tr></table></figure><p>该流程分为两个分支：</p><ol><li>如果字典中不存在相同 key 的对象，则直接将创建一个 NSCacheEntry 对象并添加到字典和排序链表中；</li><li>如果已存在相同 key 的对象，则更新字典中旧对象的 cost 和 value 。然后判断新旧对象的 cost 是否有差异，如果有，则删除排序链表中的旧元素，再插入新的元素。这里<strong>通过复用旧对象，减少了对字典的写入和删除操作</strong>。</li></ol><p>执行完上述操作后，就执行淘汰逻辑：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 根据Cost判断是否需要淘汰</span><br><span class="hljs-keyword">var</span> purgeAmount <span class="hljs-operator">=</span> (totalCostLimit <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>) <span class="hljs-operator">?</span> (_totalCost <span class="hljs-operator">-</span> totalCostLimit) : <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> purgeAmount <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 使用while循环从头开始remove元素，直到达到需要淘汰的数量，或者链表为空</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> _head &#123;  <span class="hljs-comment">// 获取head并remove</span><br>        delegate<span class="hljs-operator">?</span>.cache(<span class="hljs-built_in">unsafeDowncast</span>(<span class="hljs-keyword">self</span>, to:<span class="hljs-type">NSCache</span>&lt;<span class="hljs-type">AnyObject</span>, <span class="hljs-type">AnyObject</span>&gt;.<span class="hljs-keyword">self</span>), willEvictObject: entry.value)<br>        <br>        _totalCost <span class="hljs-operator">-=</span> entry.cost<br>        purgeAmount <span class="hljs-operator">-=</span> entry.cost<br>        <br>        <span class="hljs-comment">// 在remove的时候head会移动到下一个对象上</span><br>        remove(entry) <span class="hljs-comment">// _head will be changed to next entry in remove(_:)</span><br>        _entries[<span class="hljs-type">NSCacheKey</span>(entry.key)] <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据count判断是否需要淘汰</span><br><span class="hljs-keyword">var</span> purgeCount <span class="hljs-operator">=</span> (countLimit <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>) <span class="hljs-operator">?</span> (_entries.count <span class="hljs-operator">-</span> countLimit) : <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> purgeCount <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> _head &#123;<br>        delegate<span class="hljs-operator">?</span>.cache(<span class="hljs-built_in">unsafeDowncast</span>(<span class="hljs-keyword">self</span>, to:<span class="hljs-type">NSCache</span>&lt;<span class="hljs-type">AnyObject</span>, <span class="hljs-type">AnyObject</span>&gt;.<span class="hljs-keyword">self</span>), willEvictObject: entry.value)<br>        <br>        _totalCost <span class="hljs-operator">-=</span> entry.cost<br>        purgeCount <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><br>        <br>        remove(entry) <span class="hljs-comment">// _head will be changed to next entry in remove(_:)</span><br>        _entries[<span class="hljs-type">NSCacheKey</span>(entry.key)] <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br>_lock.unlock()<br></code></pre></td></tr></table></figure><p>Swift 中的淘汰流程分为两部分：先根据缓存的总 cost 进行淘汰，再根据总 count 进行淘汰。淘汰过程为：<strong>使用 while 循环从头开始 remove 排序双向链表中的元素，直到链表为空或者淘汰后的 cost/count 满足要求。因为是从链表的 head 开始删除，所以在 remove 的时候 head 会移动到下一个对象上</strong>。</p><p>接着去看排序链表的 <code>remove</code> 和 <code>insert</code> 。由于链表是有序的，<code>remove</code> 比较简单，如果删除的是 head，则更新 head的 位置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">entry</span>: <span class="hljs-type">NSCacheEntry</span>&lt;<span class="hljs-type">KeyType</span>, <span class="hljs-type">ObjectType</span>&gt;)</span> &#123;<br>    <span class="hljs-keyword">let</span> oldPrev <span class="hljs-operator">=</span> entry.prevByCost<br>    <span class="hljs-keyword">let</span> oldNext <span class="hljs-operator">=</span> entry.nextByCost<br>    <br>    oldPrev<span class="hljs-operator">?</span>.nextByCost <span class="hljs-operator">=</span> oldNext<br>    oldNext<span class="hljs-operator">?</span>.prevByCost <span class="hljs-operator">=</span> oldPrev<br>    <br>    <span class="hljs-keyword">if</span> entry <span class="hljs-operator">===</span> _head &#123; <span class="hljs-comment">// 如果删除的是head，则更新head的位置</span><br>        _head <span class="hljs-operator">=</span> oldNext<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>排序链表的插入操作稍显复杂，需要维持链表的排序，整个流程为：</p><ul><li>当缓存为空时，insert 的对象作为 head，insert 结束。</li><li>缓存不为空，如果 insert 的对象 cost <code>&lt;=</code> head 的 cost，将对象添加到链表头部， insert 结束</li><li>缓存不为空，如果 insert 的对象 cost <code>&gt;</code> head 的 cost，根据对象的 cost 找到合适的位置 insert，形成一个 cost 升序的双向链表</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">entry</span>: <span class="hljs-type">NSCacheEntry</span>&lt;<span class="hljs-type">KeyType</span>, <span class="hljs-type">ObjectType</span>&gt;)</span> &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> currentElement <span class="hljs-operator">=</span> _head <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当缓存为空时，insert的内容作为head</span><br>        <span class="hljs-comment">// The cache is empty</span><br>        entry.prevByCost <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>        entry.nextByCost <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>        <br>        _head <span class="hljs-operator">=</span> entry<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">guard</span> entry.cost <span class="hljs-operator">&gt;</span> currentElement.cost <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果insert的对象cost &lt;= head的cost，将对象添加到链表头部</span><br>        <span class="hljs-comment">// Insert entry at the head</span><br>        entry.prevByCost <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>        entry.nextByCost <span class="hljs-operator">=</span> currentElement<br>        currentElement.prevByCost <span class="hljs-operator">=</span> entry<br>        <br>        _head <span class="hljs-operator">=</span> entry<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果insert的对象cost &gt; head的cost 的后续操作</span><br>    <span class="hljs-comment">// 根据对象的cost找到合适的位置insert，形成一个cost升序的双向链表</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> nextByCost <span class="hljs-operator">=</span> currentElement.nextByCost, nextByCost.cost <span class="hljs-operator">&lt;</span> entry.cost &#123;<br>        currentElement <span class="hljs-operator">=</span> nextByCost<br>    &#125;<br>    <br>    <span class="hljs-comment">// Insert entry between currentElement and nextElement</span><br>    <span class="hljs-keyword">let</span> nextElement <span class="hljs-operator">=</span> currentElement.nextByCost<br>    <br>    currentElement.nextByCost <span class="hljs-operator">=</span> entry<br>    entry.prevByCost <span class="hljs-operator">=</span> currentElement<br>    <br>    entry.nextByCost <span class="hljs-operator">=</span> nextElement<br>    nextElement<span class="hljs-operator">?</span>.prevByCost <span class="hljs-operator">=</span> entry<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程图为：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c120198f89c484a9a16885d57f02f56~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ol><li>Swift 版本中的 NSCache 使用 Dictionary 存储对象，在新增内容时，尽量复用内部内容，减少字典的读写操作；</li><li>通过 NSCacheEntry 维护一个双向链表，链表从 head 到 tail 形成一个 cost 升序的 sort ，在缓存淘汰时，从 head 开始删除。淘汰的标准为两个：cost 和 count，先满足 cost，再满足 count。没有根据访问频次来维护缓存，而是根据 cost 来维护缓存，淘汰的时 cost 较小的元素；</li><li>使用 NSLock 保证线程安全。</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ul><li><strong>淘汰策略</strong>：GNUSetup 使用 LRU/LFU 机制进行淘汰，使用频率较少的元素先淘汰；Swfit Foundation 依据对象的 cost 进行淘汰，cost 较少的先淘汰</li><li><strong>数据结构</strong>：GNUSetup 中使用 maptable 存储缓存对象，使用 array 维护 LRU/LFU 排序后的对象，用于缓存淘汰；Swfit Foundation 中使用 dictionary 存储缓存对象，维护一个排序的双向链表，用于缓存淘汰</li><li><strong>线程安全</strong>：GNUSetup 中没有保证 cache 线程安全的代码；Swfit Foundation 中使用 NSLock 保证缓存读写的线程安全</li></ul><p>但是需要注意 Apple 官方的这句话：</p><blockquote><p>This is not a strict limit, and if the cache goes over the limit, an object in the cache could be evicted instantly, at a later point in time, or possibly never, all depending on the implementation details of the cache.</p></blockquote><p>NSCache 并是不严格的依据 <code>totalCostLimit</code> 和 <code>countLimit</code> 来做缓存限制的，不一定会在一超出就立马进行移除我们的缓存对象，可能在将来的某一时刻移除，这取决于缓存算法的实现。</p><h1 id="SDWebImage的应用"><a href="#SDWebImage的应用" class="headerlink" title="SDWebImage的应用"></a>SDWebImage的应用</h1><p>在 SDWebImage 中，通过将图片放到 NSCache 中，利用 NSCache 自动释放内存的特点在内存不足时自动淘汰不常用的图片。在读取图片时，先检查内存里是否有，有则直接返回；没有再从磁盘里读取。以此减少磁盘操作，保证空间合理释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)imageFromCacheForKey:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)key options:(SDImageCacheOptions)options context:(<span class="hljs-keyword">nullable</span> SDWebImageContext *)context &#123;<br>    <span class="hljs-comment">// 先检查内存里是否有，有则直接返回</span><br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-keyword">self</span> imageFromMemoryCacheForKey:key];<br>    <span class="hljs-keyword">if</span> (image) &#123;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 再从磁盘里读取</span><br>    image = [<span class="hljs-keyword">self</span> imageFromDiskCacheForKey:key options:options context:context];<br>    <span class="hljs-keyword">return</span> image;<br>&#125;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.memoryCache objectForKey:key];<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中 <code>self.memoryCache</code> 为 SDMemoryCache， SDMemoryCache 内部就是将 NSCache 扩展为了 SDMemoryCache 协议：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SDMemoryCache</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-keyword">@required</span><br>- (<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">instancetype</span>)initWithConfig:(<span class="hljs-keyword">nonnull</span> SDImageCacheConfig *)config;<br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)objectForKey:(<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">id</span>)key;<br>- (<span class="hljs-keyword">void</span>)setObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object forKey:(<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">id</span>)key;<br>- (<span class="hljs-keyword">void</span>)setObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object forKey:(<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">id</span>)key cost:(<span class="hljs-built_in">NSUInteger</span>)cost;<br>- (<span class="hljs-keyword">void</span>)removeObjectForKey:(<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">id</span>)key;<br>- (<span class="hljs-keyword">void</span>)removeAllObjects;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SDMemoryCache</span> &lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ObjectType</span>&gt; : <span class="hljs-title">NSCache</span> &lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ObjectType</span>&gt; &lt;<span class="hljs-title">SDMemoryCache</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonnull</span>, <span class="hljs-keyword">readonly</span>) SDImageCacheConfig *config;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://developer.apple.com/documentation/foundation/nscache">https://developer.apple.com/documentation/foundation/nscache</a></li><li><a href="https://nshipster.com/nshashtable-and-nsmaptable/">https://nshipster.com/nshashtable-and-nsmaptable/</a></li><li><a href="https://github.com/gnustep/libs-base/blob/master/Source/NSCache.m">https://github.com/gnustep/libs-base/blob/master/Source/NSCache.m</a></li><li><a href="https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/NSCache.swift">https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/NSCache.swift</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个iOS开发的小tips</title>
    <link href="/2020/05/09/%E5%87%A0%E4%B8%AAiOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%B0%8Ftips/"/>
    <url>/2020/05/09/%E5%87%A0%E4%B8%AAiOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%B0%8Ftips/</url>
    
    <content type="html"><![CDATA[<h2 id="clipsToBounds-vs-masksToBounds"><a href="#clipsToBounds-vs-masksToBounds" class="headerlink" title="clipsToBounds vs masksToBounds"></a>clipsToBounds vs masksToBounds</h2><h3 id="clipsToBounds"><a href="#clipsToBounds" class="headerlink" title="clipsToBounds"></a>clipsToBounds</h3><p>clipsToBounds 决定子视图的显示范围：设置为YES时，子视图超出部分将被剪裁，不会显示；设置为NO则不会剪裁。<br>clipsToBounds的默认值为NO，但是在UIScrollview中为YES。</p><p>比如view2添加到view1上，即view2为view1的subview。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIView</span> *view1 = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)];<br>view1.backgroundColor = [<span class="hljs-built_in">UIColor</span> blueColor];<br>[<span class="hljs-keyword">self</span>.view addSubview:view1];<br>    <br><span class="hljs-built_in">UIView</span> *view2 = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)];<br>view2.backgroundColor = [<span class="hljs-built_in">UIColor</span> redColor];<br>[view1 addSubview:view2];<br></code></pre></td></tr></table></figure><p>view1的clipsToBounds设置为NO时，view2超出view1的部分将不会剪裁，如图左，红色部分不会被剪裁。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">view1.clipsToBounds</span> = <span class="hljs-literal">NO</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>view1的clipsToBounds设置为YES时，view2超出view1的部分将会被剪裁，如图右，红色部分被剪掉了。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">view1.clipsToBounds</span> = <span class="hljs-literal">YES</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/5/9/171f8872d7317d7a?w=1096&h=786&f=png&s=79999" alt="clipsToBounds"></p><p>在Apple的<a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasourceprefetching/prefetching_collection_view_data?language=objc">Prefetching Collection View Data</a> 示例代码中就是将UICollectionView 的 clipsToBounds 设置为 NO以显示 cell 超出 UICollectionView 时的状态，来观察UICollectionViewCell的生命周期。</p><h3 id="masksToBounds"><a href="#masksToBounds" class="headerlink" title="masksToBounds"></a>masksToBounds</h3><p><code>masksToBounds</code>的功能和<code>clipsToBounds</code>类似，但是<code>clipsToBounds</code>是CALayer的属性，<code>clipsToBounds</code>是UIView新的属性，<code>clipsToBounds</code>会调用<code>maskToBounds</code>方法。</p><p>通常使用在设置cornerRadius不能达到圆角效果的控件上，如UIImageView、UILabel等。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">imageView.layer.cornerRadius</span> = <span class="hljs-number">5</span>.f<span class="hljs-comment">;</span><br><span class="hljs-attr">imageView.layer.masksToBounds</span> = <span class="hljs-literal">YES</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>需要注意，设置<code>maskToBounds = YES</code>可能会触发离屏渲染。关于可参考<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a>。</p><h2 id="UITextField-amp-amp-UITextView-输入限制"><a href="#UITextField-amp-amp-UITextView-输入限制" class="headerlink" title="UITextField &amp;&amp; UITextView 输入限制"></a>UITextField &amp;&amp; UITextView 输入限制</h2><p>限制文本输入可以监听<code>UIKeyboardWillChangeFrameNotification</code>通知，在其中判断文字长度。但需要注意的是：<strong>不要把高亮的部分，即联想输入的部分记入到字数统计中，因为这部分不是我们真正要输入的内容</strong>。比如在中文情况下，输入拼音时，还没有选中文字就会被键盘当作字母输入到UITextField/UITextView中，比如可输入字符还剩下1个，此时想打一个“吃”字，输入拼音“chi”，则会将计算的是“chi”三个字符的长度。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)textViewDidChange:(<span class="hljs-built_in">UITextView</span> *)textView &#123;<br>    <span class="hljs-keyword">if</span> (textView.text.length &gt; <span class="hljs-keyword">self</span>.maxInputWords &amp;&amp; !textView.markedTextRange) &#123; <span class="hljs-comment">// 防止把高亮的部分计入</span><br>        textView.text = [textView.text substringToIndex:<span class="hljs-keyword">self</span>.maxInputWords];<br>    &#125;<br>    <span class="hljs-comment">// 显示已经输入文字个数</span><br>    <span class="hljs-keyword">self</span>.wordsLabel.text = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%lu/%ld&quot;</span>, (<span class="hljs-keyword">long</span>)textView.text.length, (<span class="hljs-keyword">long</span>)<span class="hljs-keyword">self</span>.maxInputWords];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="UITextView-return键隐藏键盘"><a href="#UITextView-return键隐藏键盘" class="headerlink" title="UITextView return键隐藏键盘"></a>UITextView return键隐藏键盘</h2><p>UITextView 不像 UITextfield 一样提供了 <code>textFieldShouldReturn:</code>方法实现，可以通过 UITextViewDelegate 中的<code>textView:shouldChangeTextInRange:replacementText</code>代理方法实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)textView:(<span class="hljs-built_in">UITextView</span> *)textView shouldChangeTextInRange:(<span class="hljs-built_in">NSRange</span>)range replacementText:(<span class="hljs-built_in">NSString</span> *)text &#123;<br>    <span class="hljs-keyword">if</span> ([text isEqualToString:<span class="hljs-string">@&quot;\n&quot;</span>])&#123; <span class="hljs-comment">// 判断输入的字是否是回车，即按下 return</span><br>        [textView resignFirstResponder];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="UISwitch-开关保持原来的状态"><a href="#UISwitch-开关保持原来的状态" class="headerlink" title="UISwitch 开关保持原来的状态"></a>UISwitch 开关保持原来的状态</h2><p>UISwitch在点击时状态即会改变，如果想让它点击时不马上改变状态，而是进行其他操作之后再响应，可以在UISwitch的target方法中这样操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">switch</span> addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(switchAction:) forControlEvents:<span class="hljs-built_in">UIControlEventValueChanged</span>];<br><br>- (<span class="hljs-keyword">void</span>)switchAction:(<span class="hljs-built_in">UISwitch</span> *)sender &#123;<br><span class="hljs-comment">// 让开关状态不变</span><br>[sender setOn:!sender.on animated:<span class="hljs-literal">YES</span>];<br><br><span class="hljs-comment">// 其他操作...</span><br><br><span class="hljs-comment">// 修改开关状态</span><br>sender.on = ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>是把animated设置为YES</strong>。原因推测可能是animated有延时。</p><h2 id="UITableView-单选多选实现"><a href="#UITableView-单选多选实现" class="headerlink" title="UITableView 单选多选实现"></a>UITableView 单选多选实现</h2><p>UITableview提供了单选和多选机制，分别是<code>allowsSelection</code>和<code>allowsMultipleSelection</code>属性，但是当你想要在一个TabelView的不同section中分别使用单选和多选（比如第一个section支持单选，第二个 section 支持多选）就需要自己实现了。在 section 不多的情况下，这里提供一种快速的方案：让 UITableview 开启多选，即<code>allowsMultipleSelection=YES</code>，用变量记录单选section中上一次选中的行，在<code>tableView:didSelectRowAtIndexPath</code>中进行判断，如果选择的是不同行，则取消上一次选中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">self</span>.tableView.allowsMultipleSelection = <span class="hljs-literal">YES</span>; <span class="hljs-comment">// 允许多选</span><br><br>- (<span class="hljs-keyword">void</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath &#123;<br>    BBASuggestFeedbackHeaderModel *headerModel;<br><br>    <span class="hljs-keyword">if</span> (indexPath.section == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 取消上一次选中</span><br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.lastSelectedIndex != indexPath.row) &#123; <span class="hljs-comment">// 点击同一个不做处理</span><br>              <span class="hljs-built_in">NSIndexPath</span> *lastIndex = [<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:<span class="hljs-keyword">self</span>.lastSelectedIndex inSection:indexPath.section];<br>              [tableView deselectRowAtIndexPath:lastIndex animated:<span class="hljs-literal">YES</span>];<br>              <span class="hljs-keyword">self</span>.lastSelectedIndex = indexPath.row;<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取选中状态的cell，即可通过<code>indexPathsForSelectedRows</code>获取。</p><h2 id="UICollectionViewCell-高亮和点击态"><a href="#UICollectionViewCell-高亮和点击态" class="headerlink" title="UICollectionViewCell 高亮和点击态"></a>UICollectionViewCell 高亮和点击态</h2><p>UICollectionView不像UITableView一样默认有高亮状态，可以通过设置 UICollectionViewCell 的selectedBackgroundView实现。并且UICollectionView也提供几个高亮的代理方法</p><ul><li><code>collectionView:shouldHighlightItemAtIndexPath:</code></li><li><code>collectionView:didHighlightItemAtIndexPath:</code></li><li><code>collectionView:didUnhighlightItemAtIndexPath:</code></li></ul><p>但是如果这个时候的需求是需要在高亮的时候让cell上的其他子控件也改变alph值，单纯的设置selectedBackgroundView的不能满足。<br>可以通过重写Cell的两个方法<code>setHighlighted:</code>和<code>setSelected:</code>，</p><ul><li><code>setHighlighted:</code> 高亮状态，即按在cell上不松开的效果</li><li><code>setSelected:</code> 选中状态，点击一个cell即选中</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objc"> - (<span class="hljs-keyword">void</span>)setHighlighted:(<span class="hljs-built_in">BOOL</span>)highlighted &#123;<br>    [<span class="hljs-keyword">super</span> setHighlighted:highlighted];<br>    <br>    <span class="hljs-keyword">if</span> (highlighted) &#123;<br>    <span class="hljs-comment">// 高亮状态下的子控件颜色设置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 普通状态的子控件颜色设置</span><br>    &#125;<br>&#125;<br><br> - (<span class="hljs-keyword">void</span>)setSelected:(<span class="hljs-built_in">BOOL</span>)selected &#123;<br>    [<span class="hljs-keyword">super</span> setSelected:selected];<br><br>    <span class="hljs-keyword">if</span> (selected) &#123;<br>    <span class="hljs-comment">// 高亮状态下的子控件颜色设置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 普通状态的子控件颜色设置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Cell上UIImageView的图片不显示"><a href="#Cell上UIImageView的图片不显示" class="headerlink" title="Cell上UIImageView的图片不显示"></a>Cell上UIImageView的图片不显示</h2><p>如果cell上的UIImageView在不同情况下会size不同，圆角不同，cell复用是需要更新UIImageView的约束。遇到UIImageView中图片不显示的情况，可以从以下几个方面排查：</p><ul><li>imageView 的 frame 是否设置正确，比如采用<code>initWithImage:</code>方法初始化时，会根据图片的大小来设置imageView的frame可以不用初始化尺寸，但是大小不可控。</li><li>image view 的 hidden 是否设置</li><li>是否添加到父 view 上</li><li>是否设置 imageView 的 image</li><li>imageView 的 image 是否是从网络获取的，是否采用占位图片</li><li>imageView是否在设置圆角，圆角是否过大，比如ImageView的size为20 * 20，而圆角大小为40，则不会显示。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索iOS中Block的实现原理</title>
    <link href="/2019/04/19/%E6%8E%A2%E7%B4%A2iOS%E4%B8%ADBlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2019/04/19/%E6%8E%A2%E7%B4%A2iOS%E4%B8%ADBlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Block作为Objective-C中闭包的实现在iOS开发中占有非常重要的地位，尤其是作为回调（callback）使用。这篇文章主要记录Block的实现，关于Block的语法可以参考这里：<a href="http://fuckingblocksyntax.com/">How Do I Declare A Block in Objective-C</a></p><h1 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h1><p>Block被称为<strong>带有自动变量（局部变量）的匿名函数</strong>，Block语法去和C语言的函数非常相似。实际上Block的底层就是作为C语言源代码来处理的，支持Block的编译器会将含有Block语法的源代码转换为C语言编译器能处理的源代码，当作C语言源码来编译。</p><p>通过LLVM编译器clang可以将含有Block的语法转换为C++源码：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">clang -<span class="hljs-built_in">rewrite</span>-objc fileName<br></code></pre></td></tr></table></figure><p>比如一段非常简单的含有Block的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello Block!\n&quot;</span>);<br>&#125;;<br><br><span class="hljs-built_in">blk</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用clang将其转换为C++源码后，其核心内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *isa;<br>  <span class="hljs-keyword">int</span> Flags;<br>  <span class="hljs-keyword">int</span> Reserved;<br>  <span class="hljs-keyword">void</span> *FuncPtr;<br>&#125;;<br><br><span class="hljs-comment">// block的数据结构定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span> <br>  <span class="hljs-comment">// 构造函数</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// block中的方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello Block!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// block的数据描述</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct __main_block_impl_0)&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 调用__main_block_impl_0的构造函数</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); <br><br><span class="hljs-comment">// blk()调用</span><br>((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段源码主要包含了3个struct和两个函数，实际上就是C语言源码：</p><ul><li><strong>struct __block_impl</strong></li><li><strong>struct __main_block_impl_0</strong></li><li><strong>struct __main_block_desc_0</strong></li><li>*<em>static void __main_block_func_0(struct __main_block_impl_0 <em>__cself)</em></em></li><li><strong>int main()</strong></li></ul><p>很容易看出mian()函数就是最初代码中的mian函数，__main_block_func_0函数就是最初代码中的Block语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">^&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello Block!\n&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>由此得出：</p><ul><li><strong>通过Block使用的匿名函数实际上被当作简单的C语言函数来处理</strong></li><li><strong>根据Block语法所属的函数名（此处为mian）和该Block语法在该函数出现的顺序值（此处为0）来经clang给函数命名</strong>，即（__main_block_func_0）。</li><li>函数的参数**__cself为指向Block值的变量**，就相当于Objective-C中的self。</li></ul><p>接下来重点看看__main_block_impl_0结构体</p><p>__main_block_func_0函数的参数__cself类型声明为struct __main_block_impl_0。__main_block_impl_0就是<strong>该Block的数据结构定义</strong>，其中包含了成员变量为impl和Desc指针，impl的__block_impl结构体声明中包含了<strong>某些标志、今后版本升级所需的区域以及函数指针</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *isa; <br>  <span class="hljs-keyword">int</span> Flags; <span class="hljs-comment">// 某些标志</span><br>  <span class="hljs-keyword">int</span> Reserved; <span class="hljs-comment">// 今后版本升级所需的区域</span><br>  <span class="hljs-keyword">void</span> *FuncPtr; <span class="hljs-comment">// 函数指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Desc指针的中包含了<strong>Block的大小</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved; <span class="hljs-comment">// 今后版本升级所需的区域</span><br>  <span class="hljs-keyword">size_t</span> Block_size; <span class="hljs-comment">// Block的大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在__main_block_impl_0的构造函数中调用了impl和Desc的成员变量，这个构造函数在mian函数中被调用，为了便于阅读，将其中的转换去掉：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 调用__main_block_impl_0的构造函数</span><br>void <span class="hljs-comment">(*blk)</span><span class="hljs-comment">(void)</span> = <span class="hljs-comment">((void (*)</span><span class="hljs-comment">()</span>)&amp;__mai<span class="hljs-symbol">n_block_impl_0</span><span class="hljs-comment">((void *)</span>__mai<span class="hljs-symbol">n_block_func_0</span>, &amp;__mai<span class="hljs-symbol">n_block_desc_0</span>_DATA));<br><br><span class="hljs-comment">// 去掉转换之后</span><br>struct __mai<span class="hljs-symbol">n_block_impl_0</span> tmp = __mai<span class="hljs-symbol">n_block_impl_0</span><span class="hljs-comment">(__main_block_func_0, &amp;__main_block_desc_0_DATA)</span>;<br>struct __mai<span class="hljs-symbol">n_block_func_0</span> *blk = &amp;tmp;<br></code></pre></td></tr></table></figure><p>构造函数中使用的实参为函数指针__main_block_func_0和静态全局变量初始化的__main_block_desc_0结构体实例指针__main_block_desc_0_DATA：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 __main_block_desc_0_DATA = &#123; <br>    <span class="hljs-number">0</span>, <br>    <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过这些调用可以总结出下面两条：</p><ul><li><strong>源码将__main_block_impl_0结构体类型的自动变量，即栈上生成的结构体实例指针，赋值给__main_block_impl_0结构体指针类型的变量blk</strong>。</li><li><strong>源码使用Block，即__main_block_impl_0结构体实例的大小，进行初始化</strong>。</li></ul><p>将__main_block_impl_0结构体展开：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct __main_block_impl_0 &#123;<br>  void *isa<span class="hljs-comment">;</span><br>  int Flags<span class="hljs-comment">;</span><br>  int Reserved<span class="hljs-comment">;</span><br>  void *FuncPtr<span class="hljs-comment">;</span><br>  struct __main_block_desc_0* Desc<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在该程序中构造函数的初始化数据如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">isa</span> = &amp;_NSConcreteStackBlock<span class="hljs-comment">;</span><br><span class="hljs-attr">Flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-attr">Reserved</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-attr">FuncPtr</span> = __main_block_func_0<span class="hljs-comment">;</span><br><span class="hljs-attr">Desc</span> = &amp;__main_block_desc_0_DATA<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以看出FuncPtr = __main_block_func_0就是简单的<strong>使用函数指针FuncPtr调用函数__main_block_func_0</strong>打印Hello Block！语句，这就是最初的源码中对于block调用的实现：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">blk()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其对应的源码去掉转换之后就很清晰：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// blk()调用</span><br>((void <span class="hljs-comment">(*)(__block_impl *)</span>)((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br><span class="hljs-comment">// 去掉转换之后:</span><br><span class="hljs-comment">(*blk-&gt;impl.FuncPtr)(blk);</span><br></code></pre></td></tr></table></figure><p>到此，对于Block的创建和使用就可以这样理解：</p><ul><li><strong>创建Block时，实际上就是声明一个struct，并且初始化该struct的成员变量。</strong></li><li><strong>执行Block时，就是通过函数指针调用函数。</strong></li></ul><p>在__main_block_impl_0的构造函数中有一个_NSConcreteStackBlock：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">impl.isa</span> = &amp;_NSConcreteStackBlock<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个isa指针很容易想到Objective-C中的isa指针。在Objective-C类和对象中，每个对象都有一个isa指针，Objective中的类最终转换为struct，类中的成员变量会被声明为结构体成员，各类的结构体是基于objc_class结构体的class_t结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs abnf">typedef struct Objc_object &#123;<br>Class isa<span class="hljs-comment">;</span><br>&#125; *id<span class="hljs-comment">;</span><br><br>typedef struct obje_class *Class<span class="hljs-comment">;</span><br><br>struct objc_class &#123;<br>Class isa<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br><br>struct class_t &#123;<br>struct class_t *isa<span class="hljs-comment">;</span><br>strcut class_t *superclass<span class="hljs-comment">;</span><br>Cache cache<span class="hljs-comment">;</span><br>IMP *vtable<span class="hljs-comment">;</span><br>uintptr_t data_NEVER_USE<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>实际上<strong>Objective-C中由类生成对象就是像结构体这样生成该类生成的对象的结构体实例。生成的各个对象（即由该生成的对象的各个结构体实例），通过成员变量isa保持该类的结构体实例指针。</strong></p><p>比如一个具有成员变量valueA和valueB的TestObject类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">TestObject</span> : <span class="hljs-symbol">NSObject</span> &#123;<br>    <span class="hljs-built_in">int</span> valueA;<br>    <span class="hljs-built_in">int</span> valueB;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>其类的对象的结构体如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct TestObject&#123;<br>Class isa<span class="hljs-comment">;</span><br>int valueA<span class="hljs-comment">;</span><br>int valueB<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a355b9af62e2d1?w=1384&h=454&f=png&s=54820"></p><p><strong>在Objective-C中，每个类（比如NSObject、NSMutableArray）均生成并保持各个类的class_t结构体实例。</strong>该实例持有声明的成员变量、方法名称、方法的实现（即函数指针）、属性以及父类的指针，并被Objective-C运行时库所使用。</p><p>再看__main_block_impl_0结构体就相当于基于Objc_object的结构体的Objective-C类对象的结构体，其中的成员变量isa初始化为<code>isa = &amp;_NSConcreteStackBlock;</code>，**_NSConcreteStackBlock就相当于calss_t结构体实例，在将Block作为Objective-C对象处理时，关于该类的信息放置于_NSConcreteStackBlock中。**</p><p>实际上Block的实质<strong>Block就是Objective-C对象</strong>。</p><h1 id="Block捕获自动变量"><a href="#Block捕获自动变量" class="headerlink" title="Block捕获自动变量"></a>Block捕获自动变量</h1><h2 id="Blocks如何捕获自动变量"><a href="#Blocks如何捕获自动变量" class="headerlink" title="Blocks如何捕获自动变量"></a>Blocks如何捕获自动变量</h2><p><strong>Block作为传统回调函数的替代方法的其中一个原因是：block允许访问局部变量，能捕获所使用的变量的值，即保存该自动变量的瞬间值</strong>，比如下面这段代码，Block中保存了局部变量mul的瞬间值7，所以后面对于mul的更改不影响Block中保存的mul值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> mul = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">int</span> (^blk)(<span class="hljs-built_in">int</span>) = ^(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>) &#123;<br>    <span class="hljs-keyword">return</span> mul * <span class="hljs-built_in">num</span>;<br>&#125;;<br><br><span class="hljs-comment">// change mul</span><br>mul = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">int</span> res = blk(<span class="hljs-number">3</span>);<br>NSLog(@<span class="hljs-string">&quot;res:%d&quot;</span>, res); <span class="hljs-comment">// res:21 not 30</span><br></code></pre></td></tr></table></figure><p>通过clang来看看Block捕获自动变量之后Block的结构有什么变化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  <span class="hljs-keyword">int</span> mul; <span class="hljs-comment">// Block语法表达式中使用的自动变量被当作成员变量追加到了__main_block_impl_0结构体中</span><br>  <span class="hljs-comment">// 初始化结构体实例时，根据传递构造函数的参数对由自动变变量追加的成员变量进行初始化</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> _mul, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">mul</span>(_mul) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp; <br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>  <span class="hljs-keyword">int</span> mul = __cself-&gt;mul; <span class="hljs-comment">// bound by copy</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mul is:%d\n&quot;</span>, mul);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct __main_block_impl_0)&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> mul = <span class="hljs-number">7</span>;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, mul));<br><br>  ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析__main_block_impl_0和其构造方法可以发现：<strong>Block中使用的自动变量mul被当作成员变量追加到了__main_block_impl_0结构体中，并根据传递构造函数的参数对该成员变量进行初始化</strong>。__main_block_impl_0中结构体实例的初始化如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">impl.isa</span> = &amp;_NSConcreteStackBlock<span class="hljs-comment">;</span><br><span class="hljs-attr">impl.Flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-attr">impl.FuncPtr</span> = __main_block_func_0<span class="hljs-comment">;</span><br><span class="hljs-attr">Desc</span> = &amp;__main_block_desc_0_DATA<span class="hljs-comment">;</span><br><span class="hljs-attr">mul</span> = <span class="hljs-number">7</span><span class="hljs-comment">; // 追加的成员变量</span><br></code></pre></td></tr></table></figure><p>由此可见，<strong>在__main_block_impl_0结构体实例（即Block）中，自动变量值被捕获。</strong>可以将Block捕获自动变量总结为如下：<strong>Block在执行语法时，Block中所使用的自动变量值被保存到Block的结构体实例（即Block自身）中</strong>。即向结构体__main_block_impl_0中追加成员变量。</p><h2 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h2><p>虽然Block能捕获自动变量值，但是却不能对其进行修改，比如下面代码就会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;<br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(^blk)(<span class="hljs-keyword">void</span>) = ^ &#123;<br>val = <span class="hljs-number">1</span>; <span class="hljs-comment">// error Variable is not assignable (missing __block type specifier)</span><br>&#125;;<br><span class="hljs-built_in">blk</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;val:%d\n&quot;</span>, val);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需对val变量使用__block说明符:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>__block <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;<br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(^blk)(<span class="hljs-keyword">void</span>) = ^ &#123;<br>val = <span class="hljs-number">1</span>; <br>&#125;;<br><span class="hljs-built_in">blk</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;val:%d\n&quot;</span>, val); <span class="hljs-comment">// val:1</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将其用clang转换之后：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> __Block_byref_val_0 &#123;<br>  void *__isa;<br>  __Block_byref_val_0 *__forwarding;<br>  <span class="hljs-built_in">int</span> __flags;<br>  <span class="hljs-built_in">int</span> __size;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  __Block_byref_val_0 *<span class="hljs-keyword">val</span>; <span class="hljs-comment">// by ref</span><br><br>  <span class="hljs-constructor">__main_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__main_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">__Block_byref_val_0</span> <span class="hljs-operator">*</span><span class="hljs-params">_val</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> : <span class="hljs-keyword">val</span>(_val-&gt;__forwarding) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br>static void <span class="hljs-constructor">__main_block_func_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span> <span class="hljs-operator">*</span><span class="hljs-params">__cself</span>)</span> &#123;<br>  __Block_byref_val_0 *<span class="hljs-keyword">val</span> = __cself-&gt;<span class="hljs-keyword">val</span>; <span class="hljs-comment">// bound by ref</span><br><br>  (<span class="hljs-keyword">val</span>-&gt;__forwarding-&gt;<span class="hljs-keyword">val</span>) = <span class="hljs-number">1</span>;<br> &#125;<br><br>static void <span class="hljs-constructor">__main_block_copy_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">dst</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">src</span>)</span> &#123;<br><span class="hljs-constructor">_Block_object_assign((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>&amp;dst-&gt;<span class="hljs-keyword">val</span>, (void*)src-&gt;<span class="hljs-keyword">val</span>, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br>static void <span class="hljs-constructor">__main_block_dispose_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">src</span>)</span> &#123;<br><span class="hljs-constructor">_Block_object_dispose((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>src-&gt;<span class="hljs-keyword">val</span>, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br>static <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  void (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  void (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, sizeof(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br><span class="hljs-comment">// __block类型的变量居然变成了结构体 __block int val = 10;</span><br> <span class="hljs-constructor">__attribute__((<span class="hljs-params">__blocks__</span>(<span class="hljs-params">byref</span>)</span>)) __Block_byref_val_0 <span class="hljs-keyword">val</span> = &#123;<br> (void*)<span class="hljs-number">0</span>,<br> (__Block_byref_val_0 *)&amp;<span class="hljs-keyword">val</span>, <br> <span class="hljs-number">0</span>,<br> sizeof(__Block_byref_val_0), <br> <span class="hljs-number">10</span><br> &#125;;<br><br> void(*blk)(void) = ((void (*)<span class="hljs-literal">()</span>)&amp;<span class="hljs-constructor">__main_block_impl_0((<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;<span class="hljs-keyword">val</span>, <span class="hljs-number">570425344</span>));<br><br> ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br><br> printf(<span class="hljs-string">&quot;val:%d\n&quot;</span>, (<span class="hljs-keyword">val</span>.__forwarding-&gt;<span class="hljs-keyword">val</span>));<br><br> return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加了__block变量之后源码<strong>急剧增多</strong>，最明显的是增加了一个结构体和4个函数：</p><ul><li>struct __main_block_impl_0</li><li>static void __main_block_copy_0</li><li>static void __main_block_dispose_0</li><li>_Block_object_assign</li><li>_Block_object_dispose</li></ul><p>首先比较一下使用__block和没有使用__block的__main_block_func_0函数对变化</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 没有使用__block</span><br>static void <span class="hljs-constructor">__main_block_func_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span> <span class="hljs-operator">*</span><span class="hljs-params">__cself</span>)</span> &#123;<br>  <span class="hljs-built_in">int</span> mul = __cself-&gt;mul; <span class="hljs-comment">// bound by copy</span><br><br>  printf(<span class="hljs-string">&quot;mul is:%d\n&quot;</span>, mul);<br>&#125;<br><br><span class="hljs-comment">// 使用__block</span><br>static void <span class="hljs-constructor">__main_block_func_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span> <span class="hljs-operator">*</span><span class="hljs-params">__cself</span>)</span> &#123;<br>  __Block_byref_val_0 *<span class="hljs-keyword">val</span> = __cself-&gt;<span class="hljs-keyword">val</span>; <span class="hljs-comment">// bound by ref</span><br><br>  (<span class="hljs-keyword">val</span>-&gt;__forwarding-&gt;<span class="hljs-keyword">val</span>) = <span class="hljs-number">1</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>可以看出<strong>在没有使用__block时，Block仅仅是捕获自动变量的值</strong>，即<code>int mul = __cself-&gt;mul;</code>。</p><p>再看刚才的源码，<strong>使用__block变量的val居然变成了结构体实例</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// __block int val = 10; 转换之后的源码:</span><br><span class="hljs-constructor">__attribute__((<span class="hljs-params">__blocks__</span>(<span class="hljs-params">byref</span>)</span>)) __Block_byref_val_0 <span class="hljs-keyword">val</span> = &#123;<br> <span class="hljs-number">0</span>,<br> &amp;<span class="hljs-keyword">val</span>, <br>    <span class="hljs-number">0</span>,<br> sizeof(__Block_byref_val_0), <br> <span class="hljs-number">10</span><br> &#125;;<br></code></pre></td></tr></table></figure><p>__block变量也同Block一样变成了__Block_byref_val_0结构体类型的自动变量（栈上生成的__Block_byref_val_0结构体实例），该变量初始化为10，且这个值也出现在结构体实例的初始化中，表示<strong>该结构体持有相当于原有自动变量的成员变量</strong>(下面__Block_byref_val_0结构体中的成员变量val就是相当于原自动变量的成员变量)：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">struct <span class="hljs-variable">__Block_byref_val_0</span> &#123;<br>  void *<span class="hljs-variable">__isa</span>;<br>  <span class="hljs-variable">__Block_byref_val_0</span> *<span class="hljs-variable">__forwarding</span>;<br>  int <span class="hljs-variable">__flags</span>;<br>  int <span class="hljs-variable">__size</span>;<br>  int val; <span class="hljs-comment">// 相当于原自动变量的成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>回过头去看Block给val变量赋值的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">__main_block_func_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span> <span class="hljs-operator">*</span><span class="hljs-params">__cself</span>)</span> &#123;<br>  __Block_byref_val_0 *<span class="hljs-keyword">val</span> = __cself-&gt;<span class="hljs-keyword">val</span>; <span class="hljs-comment">// bound by ref</span><br><br>  (<span class="hljs-keyword">val</span>-&gt;__forwarding-&gt;<span class="hljs-keyword">val</span>) = <span class="hljs-number">1</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>得出：**__Block_byref_val_0结构体实例的成员变量__forwarding持有指向实例自身的指针。通过成员变量__forwarding访问成员变量val。**<br><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a3578b052de850?w=1318&h=620&f=png&s=60351"></p><p>这里没有将__block变量的__Block_byref_val_0结构体直接写在Block的__main_block_impl_0结构体中<strong>是为了能在多个Block中使用同一个__block变量</strong>。 比如在两个Block中使用同一个__block变量:</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">__block int <span class="hljs-keyword">val</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">void</span> (^blk1)(<span class="hljs-keyword">void</span>) = ^ &#123;<br><span class="hljs-keyword">val</span> = <span class="hljs-number">1</span>; <br>&#125;;<br><br><span class="hljs-keyword">void</span> (^blk2)(<span class="hljs-keyword">void</span>) = ^ &#123;<br><span class="hljs-keyword">val</span> = <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>转换之后:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">__Block_byref_val_0</span> val = &#123;(void*)<span class="hljs-number">0</span>,(__Block_byref_val_<span class="hljs-number">0</span> *)&amp;val, <span class="hljs-number">0</span>, sizeof(    __Block_byref_val_<span class="hljs-number">0</span>), <span class="hljs-number">10</span>&#125;;<br><br><span class="hljs-attribute">blk1</span> = &amp;__main_block_impl_<span class="hljs-number">0</span>(__main_block_func_<span class="hljs-number">0</span>, &amp;__main_block_desc_<span class="hljs-number">0</span>_DATA, &amp;val, <span class="hljs-number">570425344</span>);<br><br><span class="hljs-attribute">blk2</span> = &amp;__main_block_impl_<span class="hljs-number">1</span>(__main_block_func_<span class="hljs-number">1</span>, &amp;__main_block_desc_<span class="hljs-number">1</span>_DATA, &amp;val, <span class="hljs-number">570425344</span>);<br></code></pre></td></tr></table></figure><p>虽然到这里已经大致知道为什么Block能捕获自动变量了，但是这里还遗留几个问题：</p><ol><li>__Block_byref_val_0中为什么需要成员变量__forwarding？</li><li>__main_block_copy_0和__main_block_dispose_0函数的作用是什么？</li></ol><h1 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h1><p>综上可知：</p><ul><li><strong>Block转换为Block结构体类型的自动变量</strong></li><li><strong>__block变量转换为__block变量的结构体类型的自动变量</strong></li></ul><p><strong>结构体类型的自动变量即栈上说生成的该结构体的实例</strong>。</p><p>既然Block是Objective-C对象，那么它具体是哪种对象？在Block中的isa指针指向的就是该Block的Class，目前所见都是_NSConcreteStackBlock类型，而在block的runtime中实际定义了6中类型的Block，其中我们主要接触到的是这三种：</p><ul><li><strong>_NSConcreteStackBlock</strong>：创建在栈上的Block</li><li><strong>_NSConcreteGlobalBlock</strong>：作为全局变量的Block</li><li><strong>_NSConcreteMallocBlock</strong>：堆上创建的Block</li></ul><p>它们对应在程序中的内存分配：<br><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a3578cd9ebf924?w=1412&h=600&f=png&s=67464"></p><p>那么Block在什么情况下时在堆上的？什么时候时栈上的？什么时候又是全局的？</p><h2 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h2><p>_NSConcreteGlobalBlock很好理解，<strong>将Block当作全局变量使用的时候，生成的Block就是_NSConcreteGlobalBlock类对象</strong>。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Gloabl Block\n&quot;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用clang转换之后为该Block用结构体__block_impl的成员变量初始化为_NSConcreteGlobalBlock，即Block用结构体实例设置在程序内存的数据区：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">isa</span> = &amp;_NSConcreteGlobalBlock<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将全局Block存放在数据区的原为：<strong>使用全局变量的地方不能使用自动变量，所以不存在对自动变量的捕获。因此Block用结构体实例的内容不依赖于执行时的状态，所以整个程序中只需要一个实例。</strong>只有在捕获自动变量时，Block用结构体实例捕获的值才会根据执行时的状态变化。因此总结Block为_NSConcreteGlobalBlock类对象的情况如下：</p><ul><li><strong>Block当作全局变量使用时</strong></li><li><strong>Block语法表达式中不使用应捕获的自动变量时</strong></li></ul><h2 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h2><p><strong>除了上述两中情况下Block配置在程序的数据区中以外，Block语法生成的Block为_NSConcreteStackBlock类对象，且设置在栈上。</strong><br>配置在栈上的Block，如果其所属的变量作用域结束，该Block就被自动废弃。</p><h2 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h2><p>那么配置在堆上的_NSConcreteMallocBlock类在何时使用？</p><p>配置在全局变量上的Block，从变量作用域外也可以通过指针访问。但是<strong>设置在栈上的Block，如果其所属的作用域结束，该Block就被废弃；并且__block变量的也是配置在栈上的，如果其所属的变量作用域结束，则该__block变量也会被废弃</strong>。那么这时需要将Block和__block变量复制到堆上，才能让其不受变量域作用结束的影响。</p><p>Block提供了将Block和__block变量从栈上复制到堆上的方法。复制到堆上的Block将_NSConcreteMallocBlock类对象写入Block用结构体实例的成员变量isa:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">isa</span> = &amp;_NSConcreteMallocBlock<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>对于堆上的__block的访问，就是通过__forwarding实现的：**__block变量用结构体成员变量__forwarding实现无论__block变量配置在栈还是在堆上都能正确的访问__block变量。**当__block变量配置在堆上时，只要栈上的结构体成员变量__forwarding指向堆上的结构体实例，那么不管是从栈上还是从堆上的__block变量都能正确访问。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a3578e16ce4ac7?w=1546&h=992&f=png&s=140090"></p><p>并且在ARC时期，大多数情况下<strong>编译器知道在合适自动将Block从栈上复制到堆上</strong>，比如<strong>将Block作为返回值时</strong>。而当<strong>向方法或函数的参数中传递Block时，编译器不能判断，需要手动调用copy方法将栈上的Block复制到堆上</strong>，但是apple提供的一些方法已经在内部恰当的地方复制了传递过来的参数，这种情况就不需要再手动复制：</p><ul><li><strong>Cocoa框架中的方法且方法名中含有usingBlock等时</strong>；</li><li><strong>CGD的API</strong></li></ul><p>并且，不管Block配置在何存，用copy方法复制都不会出现问题。但是<strong>将Block从栈上复制到堆上时相当消耗CPU的</strong>。对于已经在堆上的Block调用copy方法，会增加其引用计数。</p><p>并且对使用__block变量的Block从栈复制到堆上时，__block变量也会收到影响：<strong>如果在1个Block中使用__block变量，当该Block从栈复制到堆时，这些__block变量也全部被从栈复制到堆上。并且此时Block持有__block变量。</strong>如果有个Block使用__block变量，在任何一个Block从栈复制到堆时，__block变量都会一并复制到堆上并被该Block持有；当剩下的Block从栈复制到堆时，被复制的Block持有__block变量，<strong>并增加其引用计数</strong>。如果配置在堆上的Block被废弃，它说使用的__block变量也就被释放。这种思考方式同Objective-C内存管理方式相同。即<strong>使用__block变量的Block持有该__block变量，当Block被废弃时，它所持有的__block变量也被废弃</strong>。</p><h1 id="Block捕获对象"><a href="#Block捕获对象" class="headerlink" title="Block捕获对象"></a>Block捕获对象</h1><p>在这里Block捕获的是__block类型的变量val，如果捕获的是Objective-C对象会有什么区别？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">int</span> main() &#123;<br>    <span class="hljs-keyword">id</span> arr = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init]; <br>    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">id</span>) = [^(<span class="hljs-keyword">id</span> obj) &#123;<br>    [arr addObject:obj];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;arr count: %ld&quot;</span>, [arr count]);<br>    &#125; <span class="hljs-keyword">copy</span>];<br><br>    blk(<span class="hljs-string">@&quot;Objective-C&quot;</span>);<br>    blk(<span class="hljs-string">@&quot;Switf&quot;</span>);<br>    blk(<span class="hljs-string">@&quot;C++&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是：<strong>Block捕获的是objective-C对象，并且调用变更该对象的方法addObject:，所以这里不会产生编译错误。这是因为block捕获的变量值是一个NSMutableArray类的对象，用C语言描述就是捕获NSMutableArray类对象用的结构体实例指针。addObject方法是使用block截获的自动变量arr的值，所以不会有任何问题</strong>，但是如果在Block内部去给捕获的arr对象赋值就会出错:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">int</span> main() &#123;<br>    <span class="hljs-keyword">id</span> arr = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init]; <br>    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">id</span>) = [^(<span class="hljs-keyword">id</span> obj) &#123;<br>        arr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObjects:obj, <span class="hljs-literal">nil</span>]; <span class="hljs-comment">// error Variable is not assignable (missing __block type specifier)</span><br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;arr count: %ld&quot;</span>, [arr count]);<br>    &#125; <span class="hljs-keyword">copy</span>];<br><br>    blk(<span class="hljs-string">@&quot;Objective-C&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>之前的代码转换之后的部分源码为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;arr, (<span class="hljs-keyword">void</span>*)src-&gt;arr, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;arr, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123;<br> <span class="hljs-number">0</span>,<br> <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0<br>&#125;;<br></code></pre></td></tr></table></figure><p>再回头看看之前<code>__block int val = 10;</code>转换之后的源码中的部分内容：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">__main_block_copy_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">dst</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">src</span>)</span> &#123;<br><span class="hljs-constructor">_Block_object_assign((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>&amp;dst-&gt;<span class="hljs-keyword">val</span>, (void*)src-&gt;<span class="hljs-keyword">val</span>, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br>static void <span class="hljs-constructor">__main_block_dispose_0(<span class="hljs-params">struct</span> <span class="hljs-params">__main_block_impl_0</span><span class="hljs-operator">*</span><span class="hljs-params">src</span>)</span> &#123;<br><span class="hljs-constructor">_Block_object_dispose((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>src-&gt;<span class="hljs-keyword">val</span>, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br>static <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  void (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  void (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125;<br></code></pre></td></tr></table></figure><p>OBjective-C对象和__block变量对比，发现在Block用的结构体部分基本相同，不同之处在于：Objective-C对象用BLOCK_FIELD_IS_OBJECT标识，__block变量是用BLOCK_FIELD_IS_BYREF标识。即通<strong>过BLOCK_FIELD_IS_OBJECT和BLOCK_FIELD_IS_BYREF参数区分copy函数和dispose函数的对象类型是对象还是__block变量。</strong></p><p>该源码中在__main_block_desc_0 结构体中增加了成员变量copy和dispose，以及作为指针赋值给该成员变量的__main_block_copy_0函数和__main_block_dispose_0函数，这两个函数的作用：</p><ul><li><p><strong>__main_block_copy_0函数中所使用的_Block_object_assign函数将对象类型对象复制给Block用结构体的成员变量arr并持有该对象，调用_Block_object_assign函数相当于retain函数，将对象赋值在对象类型的结构体成员变量中</strong>。</p></li><li><p><strong>__main_block_dispose_0函数中使用_Block_object_dispose函数释放赋值在Block用结构体成员变量arr中的对象。调用_Block_object_dispose函数相当于调用release函数，释放赋值在对象类型结构体中的对象。</strong></p></li></ul><p>这两个函数在Block从栈复制到堆和已经堆上的Block被废弃时调用：</p><ul><li><strong>Block栈上复制到堆上会调用copy函数</strong></li><li><strong>堆上的Block被废弃时会调用dispose函数</strong></li></ul><h1 id="Block使用注意事项"><a href="#Block使用注意事项" class="headerlink" title="Block使用注意事项"></a>Block使用注意事项</h1><p><strong>当Block从栈复制到堆上时，Block会持有捕获的对象</strong>，这样就容易产生循环引用。比如在self中引用了Block，Block优捕获了self，就会引起循环引用，编译器通常能检测出这种循环引用:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestObject</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestObject</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.blk = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, <span class="hljs-keyword">self</span>); <span class="hljs-comment">// warning:Capturing &#x27;self&#x27; strongly in this block is likely to lead to a retain cycle</span><br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，如果捕获到的是<strong>当前对象的成员变量对象，同样也会造成对self的引用</strong>，比如下面的代码，Block使用了self对象的的成员变量name，实际上就是捕获了self，对于编译器来说name只不过时对象用结构体的成员变量：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestObject</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestObject</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.blk = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, <span class="hljs-keyword">self</span>.name);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>解决循环引用的方法有两种：</p><ol><li><p><strong>使用__weak来声明self</strong></p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>        <span class="hljs-keyword">self</span>.blk = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, weakSelf.name);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用临时变量来避免引用self</strong></p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">id</span> tmp = <span class="hljs-keyword">self</span>.name;<br>        <span class="hljs-keyword">self</span>.blk = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, tmp);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用__weak修饰符修饰对象之后，在Block中对对象就是弱引用：</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a357b1259b5ad7?w=1550&h=576&f=png&s=85083"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>ibireme <a href="https://blog.ibireme.com/2013/11/27/objc-block/">objc 中的 block</a></li><li>Draveness <a href="https://draveness.me/block-retain-object">iOS 中的 block 是如何持有对象的</a></li><li>文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1">Blocks Programming Topics</a></li><li>《Objective-C高级编程：iOS与OS X多线程和内存管理》</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Objective-C中的对象拷贝</title>
    <link href="/2018/05/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAObjective-C%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2018/05/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAObjective-C%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通常我们在使用@property声明属性的时候，对于<code>NSString</code>、<code>NSArray</code>、 <code>NSDictionary</code>经常会使用<code>copy</code>，以及block的时候也会使用copy，接下来就是和所说copy和mutableCopy。先来思考几个问题：</p></blockquote><ol><li>copy与mutableCopy有什么区别？</li><li>使用copy/mutableCopy和直接赋值有什么区别？</li><li>深浅拷贝的区别？</li><li>自定义对象如何实现NSCopying协议？</li><li>block为什么需要使用copy?</li></ol><h2 id="copy和mutableCopy"><a href="#copy和mutableCopy" class="headerlink" title="copy和mutableCopy"></a>copy和mutableCopy</h2><p>在需要复制对象的时候，会用到NSObject类提供的copy和mutableCopy方法，通过这两个方法即可复制已有对象的副本。最常用的是赋值NSString、NSArray、NSDictionary这一类对象，那么copy和mutableCopy究竟是什么？它们有何区别？</p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>copy拷贝出来的对象类型总是不可变类型(例如, <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code>等等)</p><h2 id="mutableCopy"><a href="#mutableCopy" class="headerlink" title="mutableCopy"></a>mutableCopy</h2><p>mutableCopy拷贝出来的对象类型总是可变类型(例如, <code>NSMutableString</code>, <code>NSMutableArray</code>, <code>NSMutableDictionary</code>等等)</p><p>代码举例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">NSString * <span class="hljs-built_in">str</span> = @<span class="hljs-string">&quot;hello world&quot;</span>;<br>[<span class="hljs-built_in">str</span> <span class="hljs-built_in">copy</span>]; <span class="hljs-comment">// 拷贝出内容为hello world的NSString类型的字符串</span><br>[<span class="hljs-built_in">str</span> mutableCopy]; <span class="hljs-comment">// 拷贝出内容为hello world的NSMutableString类型的字符串</span><br></code></pre></td></tr></table></figure><p>打印出类名：<br><img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d217e1d3ad?w=1101&h=182&f=jpeg&s=71263"></p><p>同样的，对于不可变的NSArray和可变的NSMutableArray来说，这样的关系总是成立的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-built_in">NSMutableArray</span> <span class="hljs-keyword">copy</span>] =&gt; <span class="hljs-built_in">NSArray</span><br>[<span class="hljs-built_in">NSArray</span> mutableCopy] =&gt; <span class="hljs-built_in">NSMutableArray</span><br></code></pre></td></tr></table></figure><hr><h2 id="使用copy-mutableCopy和直接赋值有什么区别？"><a href="#使用copy-mutableCopy和直接赋值有什么区别？" class="headerlink" title="使用copy/mutableCopy和直接赋值有什么区别？"></a>使用copy/mutableCopy和直接赋值有什么区别？</h2><p>先看一个例子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableArray</span> * arr1 = [<span class="hljs-built_in">NSMutableArray</span> array];<br>[arr1 addObject:<span class="hljs-string">@&quot;A&quot;</span>];<br><br><span class="hljs-built_in">NSArray</span> * arr2 = [<span class="hljs-built_in">NSArray</span> array];<br>arr2 = arr1;<br><br>[arr1 addObject:<span class="hljs-string">@&quot;C&quot;</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;arr1 = %@&quot;</span>, arr1);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;arr2 = %@&quot;</span>, arr2);<br></code></pre></td></tr></table></figure><p>这段代码输入如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d21845a9b2?w=627&h=152&f=jpeg&s=28569"></p><p><code>arr1</code>是可变数组,<code>arr2</code>是一个不可变数组，明明可变数组添加对象在赋值之后，<code>arr2</code>也被影响到了。</p><p>如果将<code>arr2 = arr1</code>修改为如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">arr2 = [arr1 <span class="hljs-keyword">copy</span>];<br></code></pre></td></tr></table></figure><p>然后输出就正常了<br><img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d218814ff2?w=600&h=136&f=jpeg&s=27844"></p><p>这是为什么呢？</p><p>原因其实是和OC的多态特性有关，表面上<code>arr2</code>是一个<code>NSArray</code>类型的对象，实际上是指向一个<code>NSMutableArray</code>类型的对象，也就是<code>arr1</code>。<br>我们通过打印<code>arr1</code>和<code>arr2</code>两个对象来看就知道了：</p><ul><li><p>在直接赋值的方式下打印：</p><p>  <img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d21894a84c?w=466&h=182&f=jpeg&s=22402"></p></li><li><p>在使用copy的方式下打印:</p><p>  <img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d21874463d?w=512&h=166&f=jpeg&s=22967"></p></li></ul><p>一目了然，<strong>直接赋值之后，<code>arr1</code>和<code>arr2</code>完全就是同一个对象，指向同一个地址</strong>，所以赋值之后再给<code>arr1</code>添加对象，打印出的结果肯定也是一样的。而如果使用copy之后赋值，就是两个完全不一样的对象，后续的操作也不会有影响。</p><hr><h2 id="深拷贝-deep-copy-与浅拷贝-shallow-copy-的区别？"><a href="#深拷贝-deep-copy-与浅拷贝-shallow-copy-的区别？" class="headerlink" title="深拷贝(deep copy)与浅拷贝(shallow copy)的区别？"></a>深拷贝(deep copy)与浅拷贝(shallow copy)的区别？</h2><p>首先得清楚什么是深拷贝和浅拷贝？</p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>拷贝出来的对象与原对象地址<strong>不一致</strong>，<strong>修改拷贝对象的值对源对象的值没有任何影响。</strong> 深拷贝是直接拷贝整个对象内容到另一块内存中。</p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>拷贝出来的对象与原对象地址<strong>一致</strong>，<strong>修改拷贝对象的值会直接影响源对象的值。</strong></p><p>可以用一句话总结：<strong>浅复制就是指针拷贝；深复制就是内容拷贝</strong></p><p>或许会听过这样的说法:copy都是浅拷贝, mutableCopy都是深拷贝<br>这种浅显的理解是错误的，可以看到之前使用copy的方式下打印出来的对象的地址是不一样的，是深拷贝，这说明用<strong>从一个可变对象copy出一个不可变对象时, 是深拷贝而不是浅拷贝</strong>。</p><p>在Foundation框架中，所有的collectioon类在默认的情况下都执行浅拷贝，也就是说只拷贝容器对象本身，不复制其中的数据。这样做的目的是，容器内的对象未必都能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中的某个对象。</p><p>不过通常情况下，执行的都是浅拷贝，如果你所写的对象需要深拷贝，那么可以考虑增加一个专门执行深拷贝的方法。</p><hr><h2 id="自定义对象如何实现NSCopying协议"><a href="#自定义对象如何实现NSCopying协议" class="headerlink" title="自定义对象如何实现NSCopying协议"></a>自定义对象如何实现NSCopying协议</h2><p>虽然copy方法是在NSObject中的，如果我们自定义一个类(比如Person)，向该类的对象发送copy消息，会得到如下结果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc">Person *p = [[Person alloc] init];<br>Person *p2 = [p <span class="hljs-keyword">copy</span>];<br></code></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/5/17/1636d7d218332319?w=1119&h=383&f=jpeg&s=203347"></p><p>查看苹果官方文档会发现，如果自定义的类要实现copy功能，需要实现<code>copyWithZone</code>方法，（如果想要区分copy和mutableCopy，那么copyWithZone：应该返回不可变副本，而mutableCopyWithZone：应该返回可变副本）。这个时候可以在Person类中添加如下代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone &#123;<br>    Person *p = [[Person alloc] init];<br>    p.age = <span class="hljs-keyword">self</span>.age;<br>    p.name = <span class="hljs-keyword">self</span>.name;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后就不会报错，能正常的使用copy了。</p><p>但是在苹果官方文档上还说了一个注意事项：</p><blockquote><p>If a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first.</p></blockquote><p>意思是：如果你的类可以产生子类，那么copyWithZone：方法将被继承，子类中也必须重写<code>copyWithZone:</code>方法，并且**要先调用父类的<code>copyWithZone:</code>**。</p><p>这个时候在demo中增加一个Person的子类，并增加一个college属性，那么父类Person的<code>copyWithZone:</code>方法需要改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone &#123;<br>    Person *p = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    p.age = <span class="hljs-keyword">self</span>.age;<br>    p.name = <span class="hljs-keyword">self</span>.name;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时在子类Student中可以这样实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone &#123;<br>    Student *stu = [<span class="hljs-keyword">super</span> copyWithZone:zone];<br>    <span class="hljs-keyword">if</span> (stu) &#123;<br>        stu.college = <span class="hljs-keyword">self</span>.college;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stu;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>如果实现一个类的<code>copyWithZone:</code>方法，而该类的超类也实现了<NSCopying>协议，那么应该先调用超类的copy方法以复制继承来的实例变量，然后加入自己的代码以复制想要添加到该类中的任何附加的实例变量。</p><hr><h2 id="block中为什么要使用copy修饰？"><a href="#block中为什么要使用copy修饰？" class="headerlink" title="block中为什么要使用copy修饰？"></a>block中为什么要使用copy修饰？</h2><p>在使用block作为属性的时候，通常使用的是copy</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^clickBlock)(<span class="hljs-built_in">NSString</span> * name);<br></code></pre></td></tr></table></figure><p>使用copy修饰block其实是从MRC遗留下来的，在MRC时期，作为全局变量的block在初始化时是被存放在栈区的，这样在使用时如果block内有调用外部变量，那么block无法保留其内存，如果在出了block的初始化作用域内使用，就会引起崩溃，使用copy可以将block的内存推入堆中，这样让其拥有保存调用的外部变量的内存的能力。</p><p>在ARC下，对NSStackBLock用<code>strong</code>进行强引用的话，好像会自动对其进行copy一份，变成NSMallocBLock，所以不会crash。在ARC下，其实不使用copy修饰block也是可以的。</p><p>详细的block的实现可以参考唐巧关于block的讲解：<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/">谈Objective-C block的实现</a></p><hr><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><ul><li><a href="https://developer.apple.com/documentation/foundation/nscopying?language=objc">官方文档</a></li><li><a href="https://blog.csdn.net/enuola/article/details/7801127">Object-C中对自定义类实现NSCopying协议</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>ObjC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
